1.浮点数保留一位小数：‘{:.1f}’.format()变量填在括号里或者’{:.1f}’变量填在冒号前面
 正无穷大：float(‘inf’) 负无穷大：float(‘-inf’)
2.输入多组数据同时输出多组数据：用while True:来创建一个无线循环
e.g. while True:
    n, m = map (int,input(). split())
    if n == 0 and m == 0:
        break
print (joseph(n, m))
3.def一般写在最前面保证可读性
4.二分查找：要求输入数据有序，不断地将查找区间缩小一半来进行查找，时间复杂度为 O(log n)
e.g.基本模板：
a=list(map(int,input().split()))
low=0
high=len(a）
while low<high:
    mid=(low+high)//2
    if a[mid]<x:
        low=mid+1
    else:
        high=mid-1
return low

e.g.def binary_search(array, target):
    low = 0
    high = len(array) - 1
    while low <= high:
        mid = (low + high) // 2
        if array[mid] == target:
            return mid  # 找到了目标值，立即返回索引
        elif array[mid] < target:
            low = mid + 1
        else:
            high = mid - 1
        return None  # 或者使用 -1 表示未找到
5.bisect模块：可以用来在有序列表中查找插入位置，时间复杂度为 O(log n)
e.g.import bisect
    my_list = [1, 3, 5, 7, 9]
    bisect.insort(my_list, 4)  # 插入 4 到 my_list 中，并保持有序
    print(my_list)  # 输出[1, 3, 4, 5, 7, 9]
bisect.bisect()用来查找元素的插入位置，bisect.insort()用来插入元素并保持有序
bisect_left(arr,target,key=lambda x:x[1]) key:提取比较键
6.浅拷贝和深拷贝：
- 浅拷贝：复制对象时只复制对象的引用，而不复制对象本身，因此修改原对象也会影响副本
具体地说：不可变对象（如整数、字符串、元组）：
浅拷贝会创建这些对象的新引用。
修改浅拷贝中的不可变对象不会影响原始列表，因为不可变对象的值不能被改变，只能被重新赋值。
可变对象（如列表、字典、集合）：
浅拷贝会创建这些对象的新引用，但不会复制这些对象本身。
修改浅拷贝中的可变对象会影响原始列表，因为它们共享同一个对象。
- 深拷贝：复制对象时将对象本身也复制一份，因此修改副本不会影响原对象
e.g.import copy
    a = [1, 2, 3]
    b = a  浅拷贝
    c = copy.copy(a)  浅拷贝
    d = copy.deepcopy(a)  深拷贝，d 拥有了 a 的副本，修改 d 不影响 a
    a.append(4)
    print(a)  # [1, 2, 3, 4]
    print(b)  # [1, 2, 3, 4]
    print(c)  # [1, 2, 3，4]
    print(d)  # [1, 2, 3]
e.g.创建二维数组：
m=3
n=4
arr=[[0 for i in range(n)] for i in range(m)]  # 创建 m 行 n 列的二维数组
print(arr)  # [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]
7.sort()函数 list.sort(key=None, reverse=False)  只能被列表对象调用 直接修改原列表，而不是创建一个新的已排序列表
 reverse参数是一个布尔值，如果为True，则列表将按降序排序；默认是 False，即升序排序。
 sorted()函数 可接受列表、元组、集合等输入，并返回一个列表  sorted(iterable, key=None, reverse=False)   返回一个新的已排序列表，原列表不变
8.lambda表达式：创建小型匿名函数 用法：lambda 参数: 返回值
e.g.根据特定数学对列表排序：
data = [{'name': 'Alice', 'age': 25}, {'name': 'Bob', 'age': 20}, {'name': 'Charlie', 'age': 30}]
sorted_data = sorted(data, key=lambda x: x['age'])
print(sorted_data)
# 输出: [{'name': 'Bob', 'age': 20}, {'name': 'Alice', 'age': 25}, {'name': 'Charlie', 'age': 30}]
e.g.与map()函数结合使用：
data = [1, 2, 3, 4, 5]
result = list(map(lambda x: x**2, data))
print(result)  # [1, 4, 9, 16, 25]
9.def is_even(n):
    return n % 2 == 0
这里返回的是True或者False.
10.filter()函数：filter()函数接收一个函数和一个序列，这个函数的作用是对序列中的每个元素进行判断，返回True或False，True则保留，False则过滤。
11.math模块：
math.ceil(x)：返回不小于 x 的最小整数。
math.floor(x)：返回不大于 x 的最大整数。
math.trunc(x)：返回 x 的整数部分，舍去小数部分。
math.pow(x, y)：返回 x 的 y 次幂。
math.sqrt(x)：返回 x 的平方根。
math.log(x[, base])：返回以 base 为底的对数，默认是e。
e.g.import math
    print(math.ceil(3.14))
    print(math.pow(2,3))
12.enumerate()函数：在遍历序列（如列表、元组、字符串等）时同时获取元素的索引和值。
e.g.height = [1.8, 1.6, 1.9, 1.7, 1.5]
ass = {}
for i, h in enumerate(height, 1):
    ass[h] = i   （这里的i,num分别指索引和值，最终ass={1.8: 1, 1.6: 2, 1.9: 3, 1.7: 4, 1.5: 5}）
e.g.fruits = ['apple', 'banana', 'cherry']
   for index, fruit in enumerate(fruits):
    print(f"Index: {index}, Fruit: {fruit}")
输出：                            如果enumerate(fruits,1),输出：
# Index: 0, Fruit: apple         Index: 1, Fruit: apple
# Index: 1, Fruit: banana        Index: 2, Fruit: banana
# Index: 2, Fruit: cherry        Index: 3, Fruit: cherry

e.g.  a=['5', '3', '8', '1', '2']
enumerate(a, 1) 会生成 [(1, '5'), (2, '3'), (3, '8'), (4, '1'), (5, '2')]
13.用python内置函数计算前缀和：
import itertools
import operator
result = list(itertools.accumulate([1, 2, 3, 4], operator.add))
print(result)  # 输出: [1, 3, 6, 10]
14.*a, = map(int, input().split())     *a, 的作用是确保 a 成为一个列表
需要多次访问数据或者需要对数据进行索引、切片等操作，使用 *a, = map(int, input().split()) 将 map 对象转换为列表,相当于a = list(map(int, input().split()))。
只需要遍历一次数据 并且希望节省内存，使用 a = map(int, input().split())
15.try...except 语句用于异常处理。用来捕获并处理异常，从而防止程序因为未处理的异常而崩溃。
e.g.try:
    while True:
        line = input()
        print(line)
except EOFError:
    print("End of file reached")

16.矩阵解题技巧：1.加保护圈  2.range里面加min max

17.strip() 用于去除字符串首尾的空白字符（包括空格、制表符 \t、换行符 \n 和回车符 \r）
   语法：str.strip([chars])    input().strip().split()可以写

18.def main():
   这里写主程序的代码
   if __name__ == "__main__":
       main()
   用于使代码模块化，可以被其他脚本导入使用。
19.贪心解题技巧：1.双指针 2.二分查找
20.几种数据结构：1.stack:栈是一种只能在一端进行插入或删除的线性表，在主程序中通常使用列表（list）来实现栈。
              2.queue:队列是一种先进先出（FIFO, First-In-First-Out）的数据结构,使用 queue 模块实现
              3.heap:使用 heapq 模块实现,适用于优先队列和其他需要高效访问最小/最大元素的场景
21.时间复杂度：字典&集合：O(1),列表：O(n)
22.向列表中添加元素：append() 和 extend()
append():将一个单独的元素添加到列表的末尾。
extend():将一个可迭代对象（如列表、元组、集合等）中的所有元素添加到当前列表的末尾。
23.math.isqrt()与math.sqrt():math.isqrt()返回的是整数平方根,math.sqrt(n) 返回的是浮点数平方根
e.g.import math
print(math.sqrt(16))
print(math.isqrt(16))
输出：4.0 4
24.关于返回值：e.g.def print_greeting(name):
                     print(f"Hello, {name}!")
                 print(print_greeting("Bob"))# 调用函数并打印返回值
                 输出：Hello, Bob!
                      None
因为print_greeting 函数没有显式地使用 return 语句来返回任何值。
因此，print_greeting 函数的默认返回值是 None
25.f""：用于在字符串中嵌入变量和表达式
e.g.score = 85
print(f"You {'passed' if score >= 60 else 'failed'} the exam.")
# 输出: You passed the exam.
e.g.print(f’{a}->{c}’) a c是另外的变量
26.标准库functools模块中的函数cmp_to_key()可以将一个自定义的比较函数转换为一个键函数，用于排序。
e.g.from functools import cmp_to_key
# 定义一个旧式的比较函数
def compare_tuples(a, b):
    if a[1] < b[1]:
        return -1
    elif a[1] > b[1]:
        return 1
    else:
        return 0
# 使用 cmp_to_key 将旧式的比较函数转换为键函数
key_func = cmp_to_key(compare_tuples)
# 使用键函数进行排序
tuples = [(1, 'c'), (2, 'a'), (3, 'b')]
sorted_tuples = sorted(tuples, key=key_func)
print(sorted_tuples)  # 输出: [(2, 'a'), (3, 'b'), (1, 'c')]
27. 输出原始列表中元素按照从小到大排序后的索引（从1开始）
a=list(map(int,input().split()))
b=range(len(a))
c=sorted(b,key=lambda i:a[i])
d=[str(i+1) for i in c]
e=' '.join(d)
或者
t = sorted(enumerate(input().split(), 1), key=lambda x: int(x[1]))
#这里如果输入是5 3 8 1 2 会输出[(4, '1'), (5, '2'), (2, '3'), (1, '5'), (3, '8')]
ans = [i[0] for i in t]
print(*ans)
28. 星号操作符 * 用于解包可迭代对象（如列表、元组等）。它将列表中的每个元素作为单独的参数传递给 print 函数。
e.g. ans=[1, 2, 3, 4, 5]
print(*ans)输出 1 2 3 4 5
29.创建dp[ ]的时候小心数组越界 e.g.dp=[0]*(n+1)可以dp=[0]*n就不可以。看一下后续会访问到哪里。
30.背包问题 动态规划
0-1背包问题：每个物品只能选或不选
状态转移方程：F[i,v]=max{F[i-1,v],F[i-1,v-Ci]+Wi}
•	w[i] 表示第 i 个物品的重量。
•	v[i] 表示第 i 个物品的价值。
•	W 是背包的最大承重。
•	dp[j] 表示在不超过容量 j 的情况下能获得的最大价值。
•	最终的答案就是 dp[W]。
完全背包问题：每种物品可以选择无限多个
31. break 语句：立即终止当前所在的整个循环（for 或 while 循环），并跳出循环体。
continue 语句：跳过当前循环的剩余部分，并直接开始下一次循环迭代。
 e.g. for i in range(10):	for i in range(n):
        if i == 5:                         if i%2==0:
          break                            continue
        print(i)                           print(i)
 输出：0 1 2 3 4                    输出：1 3 5 7 9
32. print(['NO','YES'][s[int(i**0.5)]]) False索引是0，对应‘NO’ True索引是1，对应’True’
相当于
if s[int(i**0.5)]:
        print('YES')
    else:
        print('NO')
33. 埃拉托斯特尼筛法:
 def ess(n,prime):
    p=2
    while p*p<=n:
        if prime[p]==True:
            for i in range(p*2,n+1,p):
                prime[i]=False
        p+=1
   欧拉筛：
def euler(n):
    is_prime=[True]*(n+1)
    prime=[]
    for i in range(2,n+1):
        if is_prime[i]:
            prime.append(i)
        for p in prime:
            if i*p>n:
                break
            is_prime[i*p]=False
            if i%p==0:
                break
    return prime
34．a=[(1,A),(2,B),(3,C)]想要得到123的话b=[num for num,letter in a] ans=’’.join(map(str,b))就行                            或者ans=’’.join(str(item) for item in b)
    注意.join()要求列表中的所有元素都是字符串类型。
35.缓存原理 批量读取 批量输出
e.g.
import sys
input = sys.stdin.read 
output = sys.stdout.write
def solve(): 
data = input().strip().split() 
n = int(data[0]) 
results = []
for i in range(1, n + 1):
results.append(str(int(data[2*i - 1]) + int(data[2*i]))) 
output("\n".join(results) + "\n")
solve()
36.计算最大公约数：import math  result=math.gcd(a,b)
最小公倍数：import math  def lcm(a,b):  return abs(a*b)//math.gcd(a,b)
37.permutations生成给定序列的所有排列组合
e.g.import itertools 或者from itertools import permutations
items=[‘a’,’b’,’c’]
p=list(itertools.permutations(items,2))
print(‘ ‘.join(p))
38.lru_cache: 装饰器，用于实现缓存机制：最近最少使用（Least Recently Used, LRU）缓存
避免大量的重复计算，从而大幅加快执行速度。
from functools import lru_cache
@lru_cache(maxsize=128)  #指定缓存的最大大小，如果不指定，则默认为 128 个条目。如果设置为 None，则缓存没有大小限制。如果不能ac可以考虑这里改小一点。注意这一条要贴着后面的def写，表示对函数中的量缓存。 而且lru_cache的对象是不可变类型，如果是列表，集合，字典要转换成元组或其他。
def f(n,lst):
    lst=tuple(lst)
39. del 是 Python 中的一个关键字，用于删除对象，包括变量、列表中的元素、字典中的键值对等。
e.g.列表 my_list = [1, 2, 3, 4, 5]
del my_list[2]   del my_list[-1]
字典my_dict = {'a': 1, 'b': 2, 'c': 3}
del my_dict['b'] 删除键值对
集合my_set = {1, 2, 3, 4, 5}
my_set.remove(3) #用的是.remove()哈
print(my_set) 
40. 递归是一种通过调用自身来解决问题的方法。递归函数通常有一个或多个基本情况，用于终止递归调用，以及一个或多个递归情况，用于将问题分解为更小的子问题。
递推是一种通过已知的初始条件和递推关系来计算后续值的方法。递推可以看作是一种从下到上的方法，通常使用循环结构（如 for 循环或 while 循环）来逐步计算每个值。

使⽤递推写法的计算⽅式是⾃底向上(Bottom-up Approach)，即从边界开始，不断向上解决问题，直到解决了⽬标问题：⽽使⽤递归写法的计算⽅式是⾃顶向下(Top-down Approach)，即从⽬标问题开始，将它分解成⼦问题的组合，直到分解⾄边界为⽌

递归方法通常从问题的最终状态开始，逐步分解到最基本的状态。Top-Down
为了避免重复计算，可以使用记忆化（开一个memo列表或者在函数前调用lru_cache）来存储已经计算过的结果。
动态规划方法通常从最基本的状态开始，逐步构建到最终状态。Bottom-Up
41.from functools import cmp_to_key
将一个比较函数转换为关键字函数，用于排序和最大/小值计算
e.g. #病人排队 曹以楷 cmp_to_key
from functools import cmp_to_key
def cmp(x,y):
    if x[0]>=60 and y[0]>=60:
        return x[0]-y[0] #这里会有三种情况 就是x,y都是老年人时按照大小比较
    if x[0]>=60 and y[0]<60:
        return 1 #x在前
    if x[0]<60 and y[0]>=60:
        return -1 #y在前
    return 0 #表示顺序不变
n=int(input())
p=[]
for _ in range(n):
    i,a=input().split()
    a=int(a)
    p.append((a,i))
p.sort(key=cmp_to_key(cmp),reverse=True)
for x in p:
    print(x[1])







坑点合集：
1.maya canlendar: print(n)
样例输入
3
10. zac 0
0. pop 0
10. zac 1995
样例输出
3
3 chuen 0
1 imix 0
9 cimi 2801

2.radar installation: input()写在最后
样例输入
3 2
1 2
-3 1
2 1

1 2
0 2

0 0
